/*
 * EventManager
 * EventManager is a simple API allowing user to interact with EventManager.  It allows user to:  * register/unregister an EventProvider with EventManager  * get the information of a registered EventProvider  * list all the registered EventProvider  * send event to the EventBus via EventManager
 *
 * OpenAPI spec version: 
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client;

import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Properties;

import javax.ws.rs.ProcessingException;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Representation of client side of discovery service - a service for discovering API end-points.
 *
 * <p>
 * Service discovery client calls discovery service to find target service by API id.
 * By default, discovery service root URL is {@code http://aura-api-catalog:8080},
 * which can be changed using {@code API_DISCOVERY_SERVICE} environment variable
 * or {@code io.swagger.client.ServiceDiscoveryClient.url} system property.
 * API id of this API client is @{code 5245089f-a56e-4f94-8a80-9e0e787f8dc6},
 * which can be changed by {@code API_ID_OVERRIDE} environment variable
 * or {@code io.swagger.client.ServiceDiscoveryClient.api} system property.
 * </p>
 *
 * <p>
 * Service discovery results are cached for 5 minutes by default.
 * It can be changed using {@code API_DISCOVERY_EXPIRATION} environment
 * variable or {@code io.swagger.client.ServiceDiscoveryClient.expiration}
 * system property by setting cache expiration timeout in miliseconds.
 * The default value is 300000.
 * </p>
 */
 @javax.annotation.Generated(value = "com.oracle.aura.clientgen.template.java.Generator", date = "2017-12-07T15:11:31.765Z")
public abstract class ServiceDiscoveryClient {

    public static final String DISCOVERY_URL_PROPERTY_NAME = ServiceDiscoveryClient.class.getName() + ".url";
    public static final String API_ID_OVERRIDE_PROPERTY_NAME = ServiceDiscoveryClient.class.getName() + ".api";
    public static final String CACHE_EXPIRATION_PROPERTY_NAME = ServiceDiscoveryClient.class.getName() + ".expiration";

    /**
     * Connection information object produced by discovery.
     */
    public static class ConnectionInfo {
        private final String url;
        private final Map<String, String> headers;

        /**
         * URL of service.
         * @return URL as string
         */
        public String getUrl() {
            return url;
        }

        /**
         * Additional headers.
         * @return headers
         */
        public Map<String, String> getHeaders() {
            return headers;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((headers == null) ? 0 : headers.hashCode());
            result = prime * result + ((url == null) ? 0 : url.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            ConnectionInfo other = (ConnectionInfo) obj;
            if (headers == null) {
                if (other.headers != null)
                    return false;
            } else if (!headers.equals(other.headers))
                return false;
            if (url == null) {
                if (other.url != null)
                    return false;
            } else if (!url.equals(other.url))
                return false;
            return true;
        }

        /**
         * Creates connection information.
         * @param url url
         * @param headers headers
         */
        public ConnectionInfo(String url, Map<String, String> headers) {
            this.url = url;
            this.headers = headers;
            Objects.requireNonNull(url);
            Objects.requireNonNull(headers);
        }
    }

    /**
     * Exception representing failures of service discovery client
     * including ones originating from service failures.
     */
    public static class DiscoveryException extends RuntimeException {
        /**
         * Constructor.
         * @param message message
         * @param cause cause
         */
        public DiscoveryException(String message, Throwable cause) {
            super(message, cause);
        }
        /**
         * Constructor.
         * @param message message
         */
        public DiscoveryException(String message) {
            super(message);
        }
    }

    /**
     * Provides connection info of the target service.
     *
     * @param configuration configuration object
     * @param force force call discovery service (flush caches if any)
     * @return {@link ConnectionInfo}
     * @throws DiscoveryException on discovery service error
     */
    public abstract ConnectionInfo getConnectionInfo(Configuration configuration, boolean force);

    /**
     * Provides {@link ServiceDiscoveryClient} instance.
     * @return {@link ServiceDiscoveryClient} instance
     */
    public static ServiceDiscoveryClient instance() {
        // TODO: check environment variable to see which implementation to use, we eventually want to support:
        //       - plain (no caching, no polling, each request = in-the-band discovery call)
        //       - cached (results cached for some time, in-the-band discovery calls)
        //       - polling (periodical out-of-the-band discovery calls)
        //       currently we have only the plain one
        return CachedServiceDiscoveryClient.instance();
    }

    public static class CachedServiceDiscoveryClient extends ServiceDiscoveryClient {

        private final ServiceDiscoveryClient backend;
        private final long cacheExpirationTimeout;

        private ConnectionInfo cache;
        private long cacheExpiration;

        private CachedServiceDiscoveryClient(ServiceDiscoveryClient backend, long cacheExpirationTimeout) {
            this.backend = backend;
            this.cacheExpirationTimeout = cacheExpirationTimeout;
            Objects.requireNonNull(backend);
        }

        @Override
        public synchronized ConnectionInfo getConnectionInfo(Configuration config, boolean force) {
            long now = System.currentTimeMillis();
            if (force || cache == null || cacheExpiration < now) {
                cache = backend.getConnectionInfo(config, force);
                cacheExpiration = now + cacheExpirationTimeout;
            }
            return cache;
        }

        public synchronized void clearCache() {
            cache = null;
        }

        private static volatile CachedServiceDiscoveryClient instance;

        public static CachedServiceDiscoveryClient instance() {
            if (instance == null) {
                synchronized (ServiceDiscoveryClient.class) {
                    if (instance == null) {
                        instance = new CachedServiceDiscoveryClient(
                                PlainServiceDiscoveryClient.instance(),
                                getCacheExpirationTimeout());
                    }
                }
            }
            return instance;
        }

        private static long getCacheExpirationTimeout() {
            String expirationString = System.getProperty(ServiceDiscoveryClient.CACHE_EXPIRATION_PROPERTY_NAME,
                    getEnvironmentVariable("API_DISCOVERY_EXPIRATION", "300000"));
            return Long.parseLong(expirationString);
        }
    }

    public static class PlainServiceDiscoveryClient extends ServiceDiscoveryClient {

        private static final String DEFAULT_API_ID = "5245089f-a56e-4f94-8a80-9e0e787f8dc6";
        private static final String DEFAULT_DISCOVERY_SERVICE_URL = "http://aura-api-catalog:8080";

        private final Client httpClient;
        private final ObjectMapper mapper;

        @Override
        public ConnectionInfo getConnectionInfo(Configuration config, boolean force) {
            String discoveryUrl = getDiscoveryUrl();
            try {
                Response response = httpClient.target(discoveryUrl)
                        .request()
                        .accept(MediaType.APPLICATION_JSON)
                        .get();
                if (response.getStatus() == 200) {
                    String body = response.readEntity(String.class);
                    return connectionInfoFromResponseBody(body, config, discoveryUrl);
                } else {
                    throw new DiscoveryException("Discovery failed: " +
                            "status = " + response.getStatus() + ", " +
                            "message = " + extractMessage(response) + ", " +
                            "discoveryUrl = " + discoveryUrl);
                }
            } catch (ProcessingException | IllegalStateException err) {
                throw new DiscoveryException("Discovery failed due to an exception; discoveryUrl = " + discoveryUrl, err);
            }
        }

        private ConnectionInfo connectionInfoFromResponseBody(String responseBody, Configuration config, String discoveryUrl) {
            final JsonNode json;
            try {
                json = mapper.readTree(responseBody);
            } catch (IOException e) {
                throw new DiscoveryException("Discovery failed: unable to process response as JSON;"
                        + " discoveryUrl = " + discoveryUrl + ", responseBody = " + responseBody, e);
            }
            JsonNode serviceJson = json.get("service");
            if (serviceJson != null) {
                String targetUrl = extractUrl(config, serviceJson);
                Map<String, String> headers = extractHeaders(config, serviceJson, discoveryUrl);
                return new ConnectionInfo(targetUrl, headers);
            } else {
                throw new DiscoveryException("Discovery failed: Invalid response: missing `service` property;"
                        + " discoveryUrl = " + discoveryUrl);
            }
        }

        private String extractUrl(Configuration config, JsonNode json) {
            Properties props = new Properties();
            props.setProperty("base.path", config.getBasePath());
            Configuration.writeToProperties(props, json);
            return Configuration.baseUrlFromProperties(props);
        }

        private Map<String, String> extractHeaders(Configuration config, JsonNode json, String discoveryUrl) {
            Map<String, String> headers = new LinkedHashMap<>(config.getHeaders());
            JsonNode headersJson = json.get("headers");
            if (headersJson != null && headersJson.isObject()) {
                headersJson.fields().forEachRemaining(e -> {
                    JsonNode valueNode = e.getValue();
                    if (valueNode.isTextual()) {
                        headers.put(e.getKey(), valueNode.asText());
                    } else {
                        throw new DiscoveryException("Discovery failed: Invalid response: `service.headers." + e.getKey() + "` is not a string;"
                                + " discoveryUrl = " + discoveryUrl);
                    }
                });
            } else if (headersJson != null && !headersJson.isNull() && !headersJson.isObject()) {
                throw new DiscoveryException("Discovery failed: Invalid response: `service.headers` is not an object;"
                        + " discoveryUrl = " + discoveryUrl);
            }
            return headers;
        }

        private String extractMessage(Response response) {
            try {
                JsonNode messageJson = mapper.readTree(response.readEntity(String.class)).get("message");
                if (messageJson != null && messageJson.isTextual()) {
                    return messageJson.asText();
                }
            } catch (ProcessingException | IllegalStateException | IOException err) {
                // not matching body -> ignore
            }
            return "";
        }

        private static ObjectMapper createObjectMapper() {
            return new ObjectMapper();
        }

        private static Client createHttpClient() {
            return ClientBuilder.newClient();
        }

        private static String getDiscoveryUrl() {
            String discoveryServiceUrl = System.getProperty(ServiceDiscoveryClient.DISCOVERY_URL_PROPERTY_NAME,
                        getEnvironmentVariable("API_DISCOVERY_SERVICE", DEFAULT_DISCOVERY_SERVICE_URL));
            String apiId = System.getProperty(ServiceDiscoveryClient.API_ID_OVERRIDE_PROPERTY_NAME,
                        getEnvironmentVariable("API_ID_OVERRIDE", DEFAULT_API_ID));
            return discoveryServiceUrl  + "/v1/apis/" + apiId + "/api-binding";
        }

        private PlainServiceDiscoveryClient(Client httpClient, ObjectMapper mapper) {
            this.mapper = mapper;
            this.httpClient = httpClient;
        }

        private static volatile ServiceDiscoveryClient instance;

        public static ServiceDiscoveryClient instance() {
            if (instance == null) {
                synchronized (ServiceDiscoveryClient.class) {
                    if (instance == null) {
                        instance = new PlainServiceDiscoveryClient(
                                createHttpClient(),
                                createObjectMapper());
                    }
                }
            }
            return instance;
        }
    }

    static String getEnvironmentVariable(String name, String defaultValue) {
        String value = System.getenv(name);
        value = value != null ? value.trim() : "";
        return value.isEmpty() ? defaultValue : value;
    }

}
