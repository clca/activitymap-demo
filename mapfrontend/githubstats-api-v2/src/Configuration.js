/**
 * githubstats API
 * ## Version [V2]  Generate Github statistics on:  * number of commits  * number of stars  * Aggregated activity  for GitHub projects aggregated by US States
 *
 * OpenAPI spec version: 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 2.2.3
 *
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['io.test/ApiClient'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('./ApiClient'));
  } else {
    // Browser globals (root is window)
    if (!root.CatalogSwagger) {
      root.CatalogSwagger = {};
    }
    root.CatalogSwagger.Configuration = factory(root.CatalogSwagger.ApiClient);
  }
}(this, function(ApiClient) {
  'use strict';

/**
* @module Configuration
* @version 1.0.0
*/

/**
* Loads Configuration settings
* @alias module:Configuration
* @class
*/

  var API_ID = '7a916729-b5e7-45f3-ba35-d041d39a0d1b';
  var DISCOVERY_SERVICE_URL = 'http://aura-api-catalog:8080';
  var DEFAULT_NAME = 'aura-javascript-client';
  var DEFAULT_SCHEME_NAME = 'http';
  var DEFAULT_HOST = 'polls.apiblueprint.org';
  var DEFAULT_PORT = '';
  var DEFAULT_BASE_PATH_PREFIX = '';
  var DEFAULT_BASE_PATH = '/';
  var SCHEME_PROPERTY_NAME = 'protocol';
  var HOST_PROPERTY_NAME = 'host';
  var PORT_PROPERTY_NAME = 'port';
  var USER_PROPERTY_NAME = 'user';
  var PASS_PROPERTY_NAME = 'password';
  var TOKEN_PROPERTY_NAME = 'token';
  var BASE_PATH_PREFIX_PROPERTY_NAME = 'base.path.prefix';
  var BASE_PATH_PROPERTY_NAME = 'base.path';
  var BASE_URL_PROPERTY_NAME = 'base.url';
  var ROOT_URL_PROPERTY_NAME = 'root.url';
  var SECRET_JSON_FILE = 'connection.json';
  var SECRET_PROPERTIES_FILE = 'connection.properties';
  var PROPERTY_NAMES = [
    SCHEME_PROPERTY_NAME,
    HOST_PROPERTY_NAME,
    PORT_PROPERTY_NAME,
    USER_PROPERTY_NAME,
    PASS_PROPERTY_NAME,
    TOKEN_PROPERTY_NAME,
    BASE_PATH_PREFIX_PROPERTY_NAME,
    BASE_PATH_PROPERTY_NAME,
    BASE_URL_PROPERTY_NAME,
    ROOT_URL_PROPERTY_NAME,
    SECRET_JSON_FILE,
    SECRET_PROPERTIES_FILE,
  ];
  var DEFAULT_SECRET_SRC_COUNT = 2; //JSON, PROPERTIES
  var NAME_VALIDATION_PATTERN = /^[a-zA-Z.-][a-zA-Z0-9.-]*$/;
  var NON_ALPHANUMERIC_PATTERN = /[^a-zA-Z0-9]/g;
  var defaultApiClient = new ApiClient();

  var exports = function() {};

  /**
   * Creates configured {@code ApiClient} with given instance name and specified configuration properties.
   *
   * @param name of instance
   * @param configValues configuration properties
   * @return new ApiClient instance
   */
  exports.createApiClient = function(name, configValues) {
    var xName = name || DEFAULT_NAME;
    var xConfigValues = configValues || loadProperties(xName);
    validate(xName,"createApiClient(name, configValues)");
    requireNonNull(xConfigValues, "createApiClient(name, configValues)");
    return createApiClientValidated(xName, xConfigValues);
  }

  var baseUrlFromProperties = function(properties) {
    var protocol = properties[SCHEME_PROPERTY_NAME] || DEFAULT_SCHEME_NAME;
    var host = properties[HOST_PROPERTY_NAME] || DEFAULT_HOST;
    var port = (properties[PORT_PROPERTY_NAME] || DEFAULT_PORT).toString();
    var basePathPrefix = oneSlashToStartNoSlashToEnd(properties[BASE_PATH_PREFIX_PROPERTY_NAME] || DEFAULT_BASE_PATH_PREFIX);
    var basePath = oneSlashToStartNoSlashToEnd(properties[BASE_PATH_PROPERTY_NAME] || DEFAULT_BASE_PATH);
    var rootUrl = properties[ROOT_URL_PROPERTY_NAME] ||
        protocol.trim() + "://" + hostAndPort(host, port) + basePathPrefix.trim();
    rootUrl = noSlashToEnd(rootUrl);
    return properties[BASE_URL_PROPERTY_NAME] || rootUrl + basePath.trim();
  }

  var discoveryUrl = function() {
    var discoveryBaseUrl = process.env.API_DISCOVERY_SERVICE_URL || DISCOVERY_SERVICE_URL;
    var discoveryPath = '/v1/apis/' + API_ID + '/api-binding';
    return discoveryBaseUrl + discoveryPath;
  }

  /**
   * Load configuration properties by instance name with given configuration path.
   * @param name name of instance
   * @param configPath path of configuration
   * @return Properties
   */
  var loadProperties = function(name, configPath) {
    var xConfigPath = configPath || getRootPath() + "/" + name;
    //validate(name,"name-loadProperties(name, configPath)");
    //requireNonNull(xConfigPath, "configPath-loadProperties(name, xConfigPath)");
    var properties = {};
    // The order is Environment, yaml, conf (hokon), json, properties, vars_in_files
    properties = readFromFileSystem(properties, xConfigPath);
    properties = parsePropertiesSecret(properties);
    properties = parseJsonSecret(properties);
    properties = readFromEnvironment(properties, name);
    return properties;
  }

  /**
  * Private method to instantiate ApiClient with properties set
  * @param {String} name - an application name
  * @param {Object} configValues - properties object
  * @returns {Object} ApiClient object with set base path to send requests
  */
  var createApiClientValidated = function(name,/* Properties */ configValues) {
    var client = new ApiClient(name);
    client.basePath = baseUrlFromProperties(configValues);
    if (Object.keys(configValues).length === 0) {
      // empty config => discovery
      client.discoveryUrl = discoveryUrl();
      client.objectToBaseUrl = baseUrlFromProperties;
    }
    // TODO: auth
    return client;
  }

  /**
  * Read properties from file system directory
  * @param {Object} properties - properties object
  * @param {String} configPath - a folder to read the property files from
  * @returns {Object} Updated properties
  */
  var readFromFileSystem = function(properties,/* File */ configPath) {
    var fs = require('fs');
    if (fs.existsSync(configPath)) {
      if (fs.lstatSync(configPath).isDirectory()) {
        for (var index in PROPERTY_NAMES) {
          var value = valueOfFile(configPath + '/' + PROPERTY_NAMES[index]);
          if (value) {
            properties[PROPERTY_NAMES[index]] = value;
          }
        }
      }
    }
    return properties;
  }

  /**
  * Read environment properties
  * @param {Object} properties - properties object
  * @param {String} name - prefix of variables in the environment properties
  * @returns {Object} Updated properties
  */
  var readFromEnvironment = function(properties, name) {
    var envNamePrefix = envFragmentFrom(name);
    for (var index in PROPERTY_NAMES) {
      var value = process.env[envNamePrefix + '_' + envFragmentFrom(PROPERTY_NAMES[index])];
      if (value) {
        properties[PROPERTY_NAMES[index]] = value;
      }
    }
    return properties;
  }

  /**
  * Converts json file previously loaded to an obj object into given properties
  * @param {Object} properties - properties object
  * @returns {Object} Updated properties
  */
  var parseJsonSecret = function(properties) {
    var secret = properties[SECRET_JSON_FILE];
    return secret ? parsePropertiesFromSecret(properties, secret) : properties;
  }

  /**
  * Converts property file previously loaded to an obj object into given properties
  * @param {Object} properties - properties object
  * @returns {Object} Updated properties
  */
  var parsePropertiesSecret = function(properties) {
    var secret = properties[SECRET_PROPERTIES_FILE];
    var props = require('properties');
    return secret ? parsePropertiesFromSecret(properties, props.parse(secret)) : properties;
  }

  /**
  * Converts previously loaded secret json object into given properties
  * @param {Object} properties - properties object
  * @param {Object} obj - previously loaded secret to be converted into json and parsed into given properties
  * @returns {Object} Updated properties
  */
  var parsePropertiesFromSecret = function(properties, obj) {
  if (obj) {
    var secret = JSON.parse(obj);
    for (var i = 0; i != PROPERTY_NAMES.length - DEFAULT_SECRET_SRC_COUNT; i++) {
      if (secret[PROPERTY_NAMES[i]]) {
        properties[PROPERTY_NAMES[i]] = secret[PROPERTY_NAMES[i]];
      }
    }
  }
  return properties;
  }

  var envFragmentFrom = function(name) {
    return name ? name.replace(NON_ALPHANUMERIC_PATTERN,'_').toUpperCase() : name;
  }

  /**
   * Returns file path to properties file
   * @returns {String} - Either a system variable of "API_CLIENT_CONFIG_ROOT_PATH" or default path "/etc/aura/apiclient"
   */
  var getRootPath = function() {
    var env = process.env.API_CLIENT_CONFIG_ROOT_PATH || "/etc/aura/apiclient";
    env = env.trim() + "/default";
    return env;
  }

  /**
   * Read given file as object
   * @param {String} file - path to the file.
   * @returns {Object}
   */
  var valueOfFile = function(file) {
    requireNonNull(file,"valueOfFile(file)");
    var fs = require('fs');
    if (fs.existsSync(file) && !fs.lstatSync(file).isDirectory()) {
      return fs.readFileSync(file).toString();
    } else {
      return null;
    }
  }

  /**
   * Given name must match given validation regexp
   * @param {Object} name - The given name
   * @param {String} mtd - The method the code is being validated. The name is thrown in case the validation fails.
   */
  var validate = function(name, mtd) {
    requireNonNull(name, mtd);
    if (!name.match(NAME_VALIDATION_PATTERN)) {
      throw("Name must match " + NAME_VALIDATION_PATTERN);
    }
  }

  /**
   * Throw when given object is null
   * @param {Object} x - The given object
   */
  var requireNonNull = function(obj, mtd) {
  if (!obj)
    throw("Null value in method " + mtd);
  }

  /**
   * Starts with exactly one slash and remove any trailing slashes from the given text
   * @param {string} text - The given text
   */
  var oneSlashToStartNoSlashToEnd = function(text) {
    var sText = text.toString().trim();
    while (sText.startsWith('//'))
      sText = sText.length > 1 ? sText.substr(1) : '';
    sText = noSlashToEnd(sText);
    return (sText.length == 0 || sText.startsWith('/')) ? sText : '/' + sText;
  }

  /**
   * Remove any trailing slashes from the given text
   * @param {string} text - The given text
   */
  var noSlashToEnd = function(text) {
    var sText = text.toString().trim();
    while (sText.endsWith('/'))
      sText = sText.length > 1 ? sText.substr(-1) : '';
    return sText;
  }

  /**
   * Compute host:port combination from input.
   * @param {string} host - The hostname
   * @param {string} port - The port
   */
  var hostAndPort = function(host, port) {
    return host.trim() + (port ? (":" + port.trim()) : "");
  }

  //
  // Deprecated stuff follows.
  // Shall be removed once we are sure that no library template uses it.
  //

  /**
   * @deprecated will be removed without replacement
   */

  /**
   * Get the default API client, which would be used when creating API
   * instances without providing an API client.
   *
   * @return Default API client
   * @deprecated use {@link #createApiClient()} instead
   */
  var defaultApiClient = function() {
    return defaultApiClient;
  }

  return exports;
}));

